{
  "backend/package.json": "{\n  \"name\": \"university-scheduling-backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Backend API for University Course Scheduling System\",\n  \"main\": \"dist/server.js\",\n  \"scripts\": {\n    \"dev\": \"nodemon src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"seed\": \"ts-node src/scripts/seed.ts\",\n    \"migrate\": \"ts-node src/scripts/migrate.ts\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/express\": \"^4.17.0\",\n    \"mongoose\": \"^7.4.0\",\n    \"@types/mongoose\": \"^5.11.0\",\n    \"bcryptjs\": \"^2.4.3\",\n    \"@types/bcryptjs\": \"^2.4.0\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"@types/jsonwebtoken\": \"^9.0.0\",\n    \"express-validator\": \"^7.0.1\",\n    \"helmet\": \"^7.0.0\",\n    \"cors\": \"^2.8.5\",\n    \"@types/cors\": \"^2.8.0\",\n    \"morgan\": \"^1.10.0\",\n    \"@types/morgan\": \"^1.9.0\",\n    \"compression\": \"^1.7.4\",\n    \"@types/compression\": \"^1.7.0\",\n    \"dotenv\": \"^16.3.0\",\n    \"multer\": \"^1.4.5\",\n    \"@types/multer\": \"^1.4.0\",\n    \"socket.io\": \"^4.7.0\",\n    \"nodemailer\": \"^6.9.0\",\n    \"@types/nodemailer\": \"^6.4.0\",\n    \"moment-jalaali\": \"^0.9.6\",\n    \"pdfkit\": \"^0.13.0\",\n    \"@types/pdfkit\": \"^0.12.0\",\n    \"exceljs\": \"^4.3.0\",\n    \"qrcode\": \"^1.5.3\",\n    \"@types/qrcode\": \"^1.5.0\",\n    \"express-rate-limit\": \"^6.8.0\",\n    \"express-mongo-sanitize\": \"^2.2.0\",\n    \"xss-clean\": \"^0.1.1\",\n    \"hpp\": \"^0.2.3\",\n    \"cookie-parser\": \"^1.4.6\",\n    \"@types/cookie-parser\": \"^1.4.0\",\n    \"winston\": \"^3.10.0\",\n    \"joi\": \"^17.9.0\",\n    \"lodash\": \"^4.17.21\",\n    \"@types/lodash\": \"^4.14.0\",\n    \"uuid\": \"^9.0.0\",\n    \"@types/uuid\": \"^9.0.0\",\n    \"sharp\": \"^0.32.0\",\n    \"node-cron\": \"^3.0.2\",\n    \"@types/node-cron\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.0\",\n    \"ts-node\": \"^10.9.0\",\n    \"@types/node\": \"^20.4.0\",\n    \"jest\": \"^29.6.0\",\n    \"@types/jest\": \"^29.5.0\",\n    \"ts-jest\": \"^29.1.0\",\n    \"supertest\": \"^6.3.0\",\n    \"@types/supertest\": \"^2.0.0\",\n    \"eslint\": \"^8.45.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\",\n    \"prettier\": \"^3.0.0\",\n    \"eslint-config-prettier\": \"^8.8.0\",\n    \"eslint-plugin-prettier\": \"^5.0.0\"\n  }\n}",
  "backend/src/server.ts": "import app from './app'\nimport { connectDB } from './config/database'\nimport { logger } from './utils/logger'\n\nconst PORT = process.env.PORT || 5000\n\nconst startServer = async () => {\n  try {\n    // Connect to MongoDB\n    await connectDB()\n\n    // Start server\n    const server = app.listen(PORT, () => {\n      logger.info(`🚀 Server running on port ${PORT}`)\n      logger.info(`📚 University Scheduling API ready`)\n      logger.info(`🌐 Environment: ${process.env.NODE_ENV}`)\n    })\n\n    // Graceful shutdown\n    process.on('SIGTERM', () => {\n      logger.info('SIGTERM received, shutting down gracefully')\n      server.close(() => {\n        logger.info('Process terminated')\n      })\n    })\n\n    process.on('SIGINT', () => {\n      logger.info('SIGINT received, shutting down gracefully')\n      server.close(() => {\n        logger.info('Process terminated')\n      })\n    })\n\n  } catch (error) {\n    logger.error('Failed to start server:', error)\n    process.exit(1)\n  }\n}\n\nstartServer()",
  "backend/src/app.ts": "import express from 'express'\nimport cors from 'cors'\nimport helmet from 'helmet'\nimport morgan from 'morgan'\nimport compression from 'compression'\nimport cookieParser from 'cookie-parser'\nimport mongoSanitize from 'express-mongo-sanitize'\nimport xss from 'xss-clean'\nimport hpp from 'hpp'\nimport rateLimit from 'express-rate-limit'\nimport { errorHandler } from './middleware/errorHandler'\nimport { notFound } from './middleware/notFound'\nimport { logger } from './utils/logger'\n\n// Routes\nimport authRoutes from './routes/auth'\nimport userRoutes from './routes/users'\nimport scheduleRoutes from './routes/schedules'\nimport courseRoutes from './routes/courses'\nimport conflictRoutes from './routes/conflicts'\nimport exportRoutes from './routes/export'\nimport reportRoutes from './routes/reports'\n\nconst app = express()\n\n// Trust proxy\napp.set('trust proxy', 1)\n\n// Security middleware\napp.use(helmet({\n  crossOriginEmbedderPolicy: false,\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    },\n  },\n}))\n\n// CORS\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production' \n    ? process.env.FRONTEND_URL \n    : ['http://localhost:3000', 'http://127.0.0.1:3000'],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n}))\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n})\napp.use('/api/', limiter)\n\n// Body parsing middleware\napp.use(express.json({ limit: '10mb' }))\napp.use(express.urlencoded({ extended: true, limit: '10mb' }))\napp.use(cookieParser())\n\n// Data sanitization\napp.use(mongoSanitize())\napp.use(xss())\napp.use(hpp())\n\n// Compression\napp.use(compression())\n\n// Logging\nif (process.env.NODE_ENV === 'development') {\n  app.use(morgan('dev'))\n} else {\n  app.use(morgan('combined', {\n    stream: {\n      write: (message: string) => logger.info(message.substring(0, message.lastIndexOf('\\n')))\n    }\n  }))\n}\n\n// Health check\napp.get('/health', (req, res) => {\n  res.status(200).json({\n    status: 'success',\n    message: 'Server is healthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n  })\n})\n\n// API routes\napp.use('/api/auth', authRoutes)\napp.use('/api/users', userRoutes)\napp.use('/api/schedules', scheduleRoutes)\napp.use('/api/courses', courseRoutes)\napp.use('/api/conflicts', conflictRoutes)\napp.use('/api/export', exportRoutes)\napp.use('/api/reports', reportRoutes)\n\n// 404 handler\napp.use(notFound)\n\n// Global error handler\napp.use(errorHandler)\n\nexport default app",
  "backend/src/config/database.ts": "import mongoose from 'mongoose'\nimport { logger } from '../utils/logger'\n\nexport const connectDB = async (): Promise<void> => {\n  try {\n    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/university-scheduling'\n\n    const conn = await mongoose.connect(mongoURI, {\n      // useNewUrlParser: true,\n      // useUnifiedTopology: true,\n    })\n\n    logger.info(`✅ MongoDB Connected: ${conn.connection.host}`)\n\n    // Handle connection events\n    mongoose.connection.on('error', (err) => {\n      logger.error('MongoDB connection error:', err)\n    })\n\n    mongoose.connection.on('disconnected', () => {\n      logger.warn('MongoDB disconnected')\n    })\n\n    process.on('SIGINT', async () => {\n      await mongoose.connection.close()\n      logger.info('MongoDB connection closed through app termination')\n      process.exit(0)\n    })\n\n  } catch (error) {\n    logger.error('Database connection failed:', error)\n    process.exit(1)\n  }\n}",
  "backend/src/models/User.ts": "import mongoose, { Document, Schema } from 'mongoose'\nimport bcrypt from 'bcryptjs'\n\nexport interface IUser extends Document {\n  name: string\n  email: string\n  password: string\n  role: 'admin' | 'user'\n  avatar?: string\n  settings: {\n    theme: 'light' | 'dark' | 'system'\n    language: 'fa' | 'en'\n    timezone: string\n    notifications: {\n      email: boolean\n      push: boolean\n      conflicts: boolean\n      reminders: boolean\n    }\n  }\n  isActive: boolean\n  lastLogin?: Date\n  createdAt: Date\n  updatedAt: Date\n  comparePassword(candidatePassword: string): Promise<boolean>\n}\n\nconst UserSchema: Schema = new Schema({\n  name: {\n    type: String,\n    required: [true, 'نام الزامی است'],\n    trim: true,\n    maxlength: [50, 'نام نمی‌تواند بیش از ۵۰ کاراکتر باشد']\n  },\n  email: {\n    type: String,\n    required: [true, 'ایمیل الزامی است'],\n    unique: true,\n    lowercase: true,\n    trim: true,\n    match: [/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/, 'ایمیل معتبر وارد کنید']\n  },\n  password: {\n    type: String,\n    required: [true, 'رمز عبور الزامی است'],\n    minlength: [6, 'رمز عبور باید حداقل ۶ کاراکتر باشد'],\n    select: false\n  },\n  role: {\n    type: String,\n    enum: ['admin', 'user'],\n    default: 'user'\n  },\n  avatar: String,\n  settings: {\n    theme: {\n      type: String,\n      enum: ['light', 'dark', 'system'],\n      default: 'system'\n    },\n    language: {\n      type: String,\n      enum: ['fa', 'en'],\n      default: 'fa'\n    },\n    timezone: {\n      type: String,\n      default: 'Asia/Tehran'\n    },\n    notifications: {\n      email: { type: Boolean, default: true },\n      push: { type: Boolean, default: true },\n      conflicts: { type: Boolean, default: true },\n      reminders: { type: Boolean, default: true }\n    }\n  },\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLogin: Date\n}, {\n  timestamps: true,\n  toJSON: {\n    transform: function(doc, ret) {\n      delete ret.__v\n      delete ret.password\n      return ret\n    }\n  }\n})\n\n// Index for better performance\nUserSchema.index({ email: 1 })\nUserSchema.index({ createdAt: -1 })\n\n// Hash password before saving\nUserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next()\n\n  try {\n    const salt = await bcrypt.genSalt(12)\n    this.password = await bcrypt.hash(this.password, salt)\n    next()\n  } catch (error: any) {\n    next(error)\n  }\n})\n\n// Compare password method\nUserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password)\n}\n\nexport default mongoose.model<IUser>('User', UserSchema)",
  "backend/src/models/Schedule.ts": "import mongoose, { Document, Schema } from 'mongoose'\n\nexport interface ITimeSlot {\n  day: 'شنبه' | 'یکشنبه' | 'دوشنبه' | 'سه‌شنبه' | 'چهارشنبه' | 'پنج‌شنبه'\n  startTime: string // \"08:00\"\n  endTime: string   // \"09:30\"\n  location?: string\n  type: 'نظری' | 'عملی' | 'تمرین'\n}\n\nexport interface ICourse {\n  _id?: string\n  code: string\n  name: string\n  instructor: string\n  credits: number\n  group?: number\n  department?: string\n  timeSlots: ITimeSlot[]\n  examDate?: Date\n  examTime?: string\n  examLocation?: string\n  color: string\n  notes?: string\n}\n\nexport interface ISchedule extends Document {\n  userId: mongoose.Types.ObjectId\n  name: string\n  description?: string\n  semester: 'پاییز' | 'زمستان' | 'بهار' | 'تابستان'\n  year: number\n  isActive: boolean\n  courses: ICourse[]\n  totalCredits: number\n  settings: {\n    showConflicts: boolean\n    autoSave: boolean\n    gridSize: number\n    timeFormat: '12' | '24'\n  }\n  createdAt: Date\n  updatedAt: Date\n}\n\nconst TimeSlotSchema: Schema = new Schema({\n  day: {\n    type: String,\n    required: true,\n    enum: ['شنبه', 'یکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه']\n  },\n  startTime: {\n    type: String,\n    required: [true, 'زمان شروع الزامی است'],\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'فرمت زمان معتبر نیست']\n  },\n  endTime: {\n    type: String,\n    required: [true, 'زمان پایان الزامی است'],\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'فرمت زمان معتبر نیست']\n  },\n  location: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'نام مکان نمی‌تواند بیش از ۱۰۰ کاراکتر باشد']\n  },\n  type: {\n    type: String,\n    enum: ['نظری', 'عملی', 'تمرین'],\n    default: 'نظری'\n  }\n}, { _id: false })\n\nconst CourseSchema: Schema = new Schema({\n  code: {\n    type: String,\n    required: [true, 'کد درس الزامی است'],\n    trim: true,\n    uppercase: true,\n    maxlength: [20, 'کد درس نمی‌تواند بیش از ۲۰ کاراکتر باشد']\n  },\n  name: {\n    type: String,\n    required: [true, 'نام درس الزامی است'],\n    trim: true,\n    maxlength: [200, 'نام درس نمی‌تواند بیش از ۲۰۰ کاراکتر باشد']\n  },\n  instructor: {\n    type: String,\n    required: [true, 'نام استاد الزامی است'],\n    trim: true,\n    maxlength: [100, 'نام استاد نمی‌تواند بیش از ۱۰۰ کاراکتر باشد']\n  },\n  credits: {\n    type: Number,\n    required: [true, 'تعداد واحد الزامی است'],\n    min: [1, 'تعداد واحد باید حداقل ۱ باشد'],\n    max: [6, 'تعداد واحد نمی‌تواند بیش از ۶ باشد']\n  },\n  group: {\n    type: Number,\n    min: [1, 'شماره گروه باید حداقل ۱ باشد']\n  },\n  department: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'نام دانشکده نمی‌تواند بیش از ۱۰۰ کاراکتر باشد']\n  },\n  timeSlots: {\n    type: [TimeSlotSchema],\n    required: [true, 'حداقل یک زمان برای درس الزامی است'],\n    validate: {\n      validator: function(slots: ITimeSlot[]) {\n        return slots.length > 0\n      },\n      message: 'درس باید حداقل یک زمان داشته باشد'\n    }\n  },\n  examDate: Date,\n  examTime: {\n    type: String,\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'فرمت زمان امتحان معتبر نیست']\n  },\n  examLocation: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'مکان امتحان نمی‌تواند بیش از ۱۰۰ کاراکتر باشد']\n  },\n  color: {\n    type: String,\n    default: '#3B82F6',\n    match: [/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, 'رنگ باید در فرمت hex باشد']\n  },\n  notes: {\n    type: String,\n    maxlength: [500, 'یادداشت نمی‌تواند بیش از ۵۰۰ کاراکتر باشد']\n  }\n}, { timestamps: true })\n\nconst ScheduleSchema: Schema = new Schema({\n  userId: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  name: {\n    type: String,\n    required: [true, 'نام برنامه الزامی است'],\n    trim: true,\n    maxlength: [100, 'نام برنامه نمی‌تواند بیش از ۱۰۰ کاراکتر باشد']\n  },\n  description: {\n    type: String,\n    trim: true,\n    maxlength: [500, 'توضیحات نمی‌تواند بیش از ۵۰۰ کاراکتر باشد']\n  },\n  semester: {\n    type: String,\n    required: [true, 'ترم الزامی است'],\n    enum: ['پاییز', 'زمستان', 'بهار', 'تابستان']\n  },\n  year: {\n    type: Number,\n    required: [true, 'سال الزامی است'],\n    min: [1400, 'سال باید از ۱۴۰۰ به بعد باشد'],\n    max: [1450, 'سال نمی‌تواند بیش از ۱۴۵۰ باشد']\n  },\n  isActive: {\n    type: Boolean,\n    default: false\n  },\n  courses: {\n    type: [CourseSchema],\n    default: []\n  },\n  settings: {\n    showConflicts: { type: Boolean, default: true },\n    autoSave: { type: Boolean, default: true },\n    gridSize: { type: Number, default: 30, min: 15, max: 60 },\n    timeFormat: { type: String, enum: ['12', '24'], default: '24' }\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n})\n\n// Virtual for total credits\nScheduleSchema.virtual('totalCredits').get(function() {\n  return this.courses.reduce((total: number, course: ICourse) => total + course.credits, 0)\n})\n\n// Indexes\nScheduleSchema.index({ userId: 1, createdAt: -1 })\nScheduleSchema.index({ userId: 1, isActive: -1 })\nScheduleSchema.index({ 'courses.code': 1 })\nScheduleSchema.index({ 'courses.instructor': 1 })\n\n// Ensure only one active schedule per user\nScheduleSchema.pre('save', async function(next) {\n  if (this.isActive && this.isModified('isActive')) {\n    await mongoose.model('Schedule').updateMany(\n      { userId: this.userId, _id: { $ne: this._id } },\n      { isActive: false }\n    )\n  }\n  next()\n})\n\nexport default mongoose.model<ISchedule>('Schedule', ScheduleSchema)",
  "backend/src/controllers/authController.ts": "import { Request, Response, NextFunction } from 'express'\nimport jwt from 'jsonwebtoken'\nimport { validationResult } from 'express-validator'\nimport User, { IUser } from '../models/User'\nimport { asyncHandler } from '../utils/asyncHandler'\nimport { AppError } from '../utils/AppError'\nimport { logger } from '../utils/logger'\n\nconst signToken = (id: string) => {\n  return jwt.sign({ id }, process.env.JWT_SECRET!, {\n    expiresIn: process.env.JWT_EXPIRE || '7d',\n  })\n}\n\nconst createSendToken = (user: IUser, statusCode: number, res: Response) => {\n  const token = signToken(user._id)\n\n  const cookieOptions = {\n    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax' as const,\n  }\n\n  res.cookie('jwt', token, cookieOptions)\n\n  // Update last login\n  user.lastLogin = new Date()\n  user.save({ validateBeforeSave: false })\n\n  res.status(statusCode).json({\n    status: 'success',\n    token,\n    data: {\n      user,\n    },\n  })\n}\n\nexport const register = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('اطلاعات وارد شده معتبر نیست', 400, errors.array()))\n  }\n\n  const { name, email, password } = req.body\n\n  // Check if user already exists\n  const existingUser = await User.findOne({ email })\n  if (existingUser) {\n    return next(new AppError('کاربری با این ایمیل قبلاً ثبت‌نام کرده است', 400))\n  }\n\n  // Create user\n  const user = await User.create({\n    name,\n    email,\n    password,\n  })\n\n  logger.info(`New user registered: ${email}`)\n  createSendToken(user, 201, res)\n})\n\nexport const login = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('اطلاعات وارد شده معتبر نیست', 400, errors.array()))\n  }\n\n  const { email, password } = req.body\n\n  // Check if user exists and password is correct\n  const user = await User.findOne({ email }).select('+password')\n\n  if (!user || !(await user.comparePassword(password))) {\n    return next(new AppError('ایمیل یا رمز عبور اشتباه است', 401))\n  }\n\n  if (!user.isActive) {\n    return next(new AppError('حساب کاربری شما غیرفعال است', 401))\n  }\n\n  logger.info(`User logged in: ${email}`)\n  createSendToken(user, 200, res)\n})\n\nexport const logout = asyncHandler(async (req: Request, res: Response) => {\n  res.cookie('jwt', 'loggedout', {\n    expires: new Date(Date.now() + 10 * 1000),\n    httpOnly: true,\n  })\n\n  res.status(200).json({\n    status: 'success',\n    message: 'با موفقیت خارج شدید'\n  })\n})\n\nexport const getMe = asyncHandler(async (req: Request, res: Response) => {\n  const user = await User.findById((req as any).user.id)\n\n  res.status(200).json({\n    status: 'success',\n    data: {\n      user,\n    },\n  })\n})\n\nexport const updatePassword = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('اطلاعات وارد شده معتبر نیست', 400, errors.array()))\n  }\n\n  const { currentPassword, newPassword } = req.body\n\n  // Get user with password\n  const user = await User.findById((req as any).user.id).select('+password')\n\n  if (!user) {\n    return next(new AppError('کاربر یافت نشد', 404))\n  }\n\n  // Check current password\n  if (!(await user.comparePassword(currentPassword))) {\n    return next(new AppError('رمز عبور فعلی اشتباه است', 401))\n  }\n\n  // Update password\n  user.password = newPassword\n  await user.save()\n\n  logger.info(`Password updated for user: ${user.email}`)\n  createSendToken(user, 200, res)\n})\n\nexport const refreshToken = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const user = await User.findById((req as any).user.id)\n\n  if (!user) {\n    return next(new AppError('کاربر یافت نشد', 404))\n  }\n\n  createSendToken(user, 200, res)\n})"
}