{
  "backend/package.json": "{\n  \"name\": \"university-scheduling-backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Backend API for University Course Scheduling System\",\n  \"main\": \"dist/server.js\",\n  \"scripts\": {\n    \"dev\": \"nodemon src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"seed\": \"ts-node src/scripts/seed.ts\",\n    \"migrate\": \"ts-node src/scripts/migrate.ts\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/express\": \"^4.17.0\",\n    \"mongoose\": \"^7.4.0\",\n    \"@types/mongoose\": \"^5.11.0\",\n    \"bcryptjs\": \"^2.4.3\",\n    \"@types/bcryptjs\": \"^2.4.0\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"@types/jsonwebtoken\": \"^9.0.0\",\n    \"express-validator\": \"^7.0.1\",\n    \"helmet\": \"^7.0.0\",\n    \"cors\": \"^2.8.5\",\n    \"@types/cors\": \"^2.8.0\",\n    \"morgan\": \"^1.10.0\",\n    \"@types/morgan\": \"^1.9.0\",\n    \"compression\": \"^1.7.4\",\n    \"@types/compression\": \"^1.7.0\",\n    \"dotenv\": \"^16.3.0\",\n    \"multer\": \"^1.4.5\",\n    \"@types/multer\": \"^1.4.0\",\n    \"socket.io\": \"^4.7.0\",\n    \"nodemailer\": \"^6.9.0\",\n    \"@types/nodemailer\": \"^6.4.0\",\n    \"moment-jalaali\": \"^0.9.6\",\n    \"pdfkit\": \"^0.13.0\",\n    \"@types/pdfkit\": \"^0.12.0\",\n    \"exceljs\": \"^4.3.0\",\n    \"qrcode\": \"^1.5.3\",\n    \"@types/qrcode\": \"^1.5.0\",\n    \"express-rate-limit\": \"^6.8.0\",\n    \"express-mongo-sanitize\": \"^2.2.0\",\n    \"xss-clean\": \"^0.1.1\",\n    \"hpp\": \"^0.2.3\",\n    \"cookie-parser\": \"^1.4.6\",\n    \"@types/cookie-parser\": \"^1.4.0\",\n    \"winston\": \"^3.10.0\",\n    \"joi\": \"^17.9.0\",\n    \"lodash\": \"^4.17.21\",\n    \"@types/lodash\": \"^4.14.0\",\n    \"uuid\": \"^9.0.0\",\n    \"@types/uuid\": \"^9.0.0\",\n    \"sharp\": \"^0.32.0\",\n    \"node-cron\": \"^3.0.2\",\n    \"@types/node-cron\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.0\",\n    \"ts-node\": \"^10.9.0\",\n    \"@types/node\": \"^20.4.0\",\n    \"jest\": \"^29.6.0\",\n    \"@types/jest\": \"^29.5.0\",\n    \"ts-jest\": \"^29.1.0\",\n    \"supertest\": \"^6.3.0\",\n    \"@types/supertest\": \"^2.0.0\",\n    \"eslint\": \"^8.45.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\",\n    \"prettier\": \"^3.0.0\",\n    \"eslint-config-prettier\": \"^8.8.0\",\n    \"eslint-plugin-prettier\": \"^5.0.0\"\n  }\n}",
  "backend/src/server.ts": "import app from './app'\nimport { connectDB } from './config/database'\nimport { logger } from './utils/logger'\n\nconst PORT = process.env.PORT || 5000\n\nconst startServer = async () => {\n  try {\n    // Connect to MongoDB\n    await connectDB()\n\n    // Start server\n    const server = app.listen(PORT, () => {\n      logger.info(`ğŸš€ Server running on port ${PORT}`)\n      logger.info(`ğŸ“š University Scheduling API ready`)\n      logger.info(`ğŸŒ Environment: ${process.env.NODE_ENV}`)\n    })\n\n    // Graceful shutdown\n    process.on('SIGTERM', () => {\n      logger.info('SIGTERM received, shutting down gracefully')\n      server.close(() => {\n        logger.info('Process terminated')\n      })\n    })\n\n    process.on('SIGINT', () => {\n      logger.info('SIGINT received, shutting down gracefully')\n      server.close(() => {\n        logger.info('Process terminated')\n      })\n    })\n\n  } catch (error) {\n    logger.error('Failed to start server:', error)\n    process.exit(1)\n  }\n}\n\nstartServer()",
  "backend/src/app.ts": "import express from 'express'\nimport cors from 'cors'\nimport helmet from 'helmet'\nimport morgan from 'morgan'\nimport compression from 'compression'\nimport cookieParser from 'cookie-parser'\nimport mongoSanitize from 'express-mongo-sanitize'\nimport xss from 'xss-clean'\nimport hpp from 'hpp'\nimport rateLimit from 'express-rate-limit'\nimport { errorHandler } from './middleware/errorHandler'\nimport { notFound } from './middleware/notFound'\nimport { logger } from './utils/logger'\n\n// Routes\nimport authRoutes from './routes/auth'\nimport userRoutes from './routes/users'\nimport scheduleRoutes from './routes/schedules'\nimport courseRoutes from './routes/courses'\nimport conflictRoutes from './routes/conflicts'\nimport exportRoutes from './routes/export'\nimport reportRoutes from './routes/reports'\n\nconst app = express()\n\n// Trust proxy\napp.set('trust proxy', 1)\n\n// Security middleware\napp.use(helmet({\n  crossOriginEmbedderPolicy: false,\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    },\n  },\n}))\n\n// CORS\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production' \n    ? process.env.FRONTEND_URL \n    : ['http://localhost:3000', 'http://127.0.0.1:3000'],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n}))\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n})\napp.use('/api/', limiter)\n\n// Body parsing middleware\napp.use(express.json({ limit: '10mb' }))\napp.use(express.urlencoded({ extended: true, limit: '10mb' }))\napp.use(cookieParser())\n\n// Data sanitization\napp.use(mongoSanitize())\napp.use(xss())\napp.use(hpp())\n\n// Compression\napp.use(compression())\n\n// Logging\nif (process.env.NODE_ENV === 'development') {\n  app.use(morgan('dev'))\n} else {\n  app.use(morgan('combined', {\n    stream: {\n      write: (message: string) => logger.info(message.substring(0, message.lastIndexOf('\\n')))\n    }\n  }))\n}\n\n// Health check\napp.get('/health', (req, res) => {\n  res.status(200).json({\n    status: 'success',\n    message: 'Server is healthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n  })\n})\n\n// API routes\napp.use('/api/auth', authRoutes)\napp.use('/api/users', userRoutes)\napp.use('/api/schedules', scheduleRoutes)\napp.use('/api/courses', courseRoutes)\napp.use('/api/conflicts', conflictRoutes)\napp.use('/api/export', exportRoutes)\napp.use('/api/reports', reportRoutes)\n\n// 404 handler\napp.use(notFound)\n\n// Global error handler\napp.use(errorHandler)\n\nexport default app",
  "backend/src/config/database.ts": "import mongoose from 'mongoose'\nimport { logger } from '../utils/logger'\n\nexport const connectDB = async (): Promise<void> => {\n  try {\n    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/university-scheduling'\n\n    const conn = await mongoose.connect(mongoURI, {\n      // useNewUrlParser: true,\n      // useUnifiedTopology: true,\n    })\n\n    logger.info(`âœ… MongoDB Connected: ${conn.connection.host}`)\n\n    // Handle connection events\n    mongoose.connection.on('error', (err) => {\n      logger.error('MongoDB connection error:', err)\n    })\n\n    mongoose.connection.on('disconnected', () => {\n      logger.warn('MongoDB disconnected')\n    })\n\n    process.on('SIGINT', async () => {\n      await mongoose.connection.close()\n      logger.info('MongoDB connection closed through app termination')\n      process.exit(0)\n    })\n\n  } catch (error) {\n    logger.error('Database connection failed:', error)\n    process.exit(1)\n  }\n}",
  "backend/src/models/User.ts": "import mongoose, { Document, Schema } from 'mongoose'\nimport bcrypt from 'bcryptjs'\n\nexport interface IUser extends Document {\n  name: string\n  email: string\n  password: string\n  role: 'admin' | 'user'\n  avatar?: string\n  settings: {\n    theme: 'light' | 'dark' | 'system'\n    language: 'fa' | 'en'\n    timezone: string\n    notifications: {\n      email: boolean\n      push: boolean\n      conflicts: boolean\n      reminders: boolean\n    }\n  }\n  isActive: boolean\n  lastLogin?: Date\n  createdAt: Date\n  updatedAt: Date\n  comparePassword(candidatePassword: string): Promise<boolean>\n}\n\nconst UserSchema: Schema = new Schema({\n  name: {\n    type: String,\n    required: [true, 'Ù†Ø§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    trim: true,\n    maxlength: [50, 'Ù†Ø§Ù… Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² ÛµÛ° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  email: {\n    type: String,\n    required: [true, 'Ø§ÛŒÙ…ÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    unique: true,\n    lowercase: true,\n    trim: true,\n    match: [/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/, 'Ø§ÛŒÙ…ÛŒÙ„ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯']\n  },\n  password: {\n    type: String,\n    required: [true, 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    minlength: [6, 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û¶ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯'],\n    select: false\n  },\n  role: {\n    type: String,\n    enum: ['admin', 'user'],\n    default: 'user'\n  },\n  avatar: String,\n  settings: {\n    theme: {\n      type: String,\n      enum: ['light', 'dark', 'system'],\n      default: 'system'\n    },\n    language: {\n      type: String,\n      enum: ['fa', 'en'],\n      default: 'fa'\n    },\n    timezone: {\n      type: String,\n      default: 'Asia/Tehran'\n    },\n    notifications: {\n      email: { type: Boolean, default: true },\n      push: { type: Boolean, default: true },\n      conflicts: { type: Boolean, default: true },\n      reminders: { type: Boolean, default: true }\n    }\n  },\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLogin: Date\n}, {\n  timestamps: true,\n  toJSON: {\n    transform: function(doc, ret) {\n      delete ret.__v\n      delete ret.password\n      return ret\n    }\n  }\n})\n\n// Index for better performance\nUserSchema.index({ email: 1 })\nUserSchema.index({ createdAt: -1 })\n\n// Hash password before saving\nUserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next()\n\n  try {\n    const salt = await bcrypt.genSalt(12)\n    this.password = await bcrypt.hash(this.password, salt)\n    next()\n  } catch (error: any) {\n    next(error)\n  }\n})\n\n// Compare password method\nUserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password)\n}\n\nexport default mongoose.model<IUser>('User', UserSchema)",
  "backend/src/models/Schedule.ts": "import mongoose, { Document, Schema } from 'mongoose'\n\nexport interface ITimeSlot {\n  day: 'Ø´Ù†Ø¨Ù‡' | 'ÛŒÚ©Ø´Ù†Ø¨Ù‡' | 'Ø¯ÙˆØ´Ù†Ø¨Ù‡' | 'Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡' | 'Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡' | 'Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡'\n  startTime: string // \"08:00\"\n  endTime: string   // \"09:30\"\n  location?: string\n  type: 'Ù†Ø¸Ø±ÛŒ' | 'Ø¹Ù…Ù„ÛŒ' | 'ØªÙ…Ø±ÛŒÙ†'\n}\n\nexport interface ICourse {\n  _id?: string\n  code: string\n  name: string\n  instructor: string\n  credits: number\n  group?: number\n  department?: string\n  timeSlots: ITimeSlot[]\n  examDate?: Date\n  examTime?: string\n  examLocation?: string\n  color: string\n  notes?: string\n}\n\nexport interface ISchedule extends Document {\n  userId: mongoose.Types.ObjectId\n  name: string\n  description?: string\n  semester: 'Ù¾Ø§ÛŒÛŒØ²' | 'Ø²Ù…Ø³ØªØ§Ù†' | 'Ø¨Ù‡Ø§Ø±' | 'ØªØ§Ø¨Ø³ØªØ§Ù†'\n  year: number\n  isActive: boolean\n  courses: ICourse[]\n  totalCredits: number\n  settings: {\n    showConflicts: boolean\n    autoSave: boolean\n    gridSize: number\n    timeFormat: '12' | '24'\n  }\n  createdAt: Date\n  updatedAt: Date\n}\n\nconst TimeSlotSchema: Schema = new Schema({\n  day: {\n    type: String,\n    required: true,\n    enum: ['Ø´Ù†Ø¨Ù‡', 'ÛŒÚ©Ø´Ù†Ø¨Ù‡', 'Ø¯ÙˆØ´Ù†Ø¨Ù‡', 'Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡', 'Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡', 'Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡']\n  },\n  startTime: {\n    type: String,\n    required: [true, 'Ø²Ù…Ø§Ù† Ø´Ø±ÙˆØ¹ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'ÙØ±Ù…Øª Ø²Ù…Ø§Ù† Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª']\n  },\n  endTime: {\n    type: String,\n    required: [true, 'Ø²Ù…Ø§Ù† Ù¾Ø§ÛŒØ§Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'ÙØ±Ù…Øª Ø²Ù…Ø§Ù† Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª']\n  },\n  location: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'Ù†Ø§Ù… Ù…Ú©Ø§Ù† Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  type: {\n    type: String,\n    enum: ['Ù†Ø¸Ø±ÛŒ', 'Ø¹Ù…Ù„ÛŒ', 'ØªÙ…Ø±ÛŒÙ†'],\n    default: 'Ù†Ø¸Ø±ÛŒ'\n  }\n}, { _id: false })\n\nconst CourseSchema: Schema = new Schema({\n  code: {\n    type: String,\n    required: [true, 'Ú©Ø¯ Ø¯Ø±Ø³ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    trim: true,\n    uppercase: true,\n    maxlength: [20, 'Ú©Ø¯ Ø¯Ø±Ø³ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û²Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  name: {\n    type: String,\n    required: [true, 'Ù†Ø§Ù… Ø¯Ø±Ø³ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    trim: true,\n    maxlength: [200, 'Ù†Ø§Ù… Ø¯Ø±Ø³ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û²Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  instructor: {\n    type: String,\n    required: [true, 'Ù†Ø§Ù… Ø§Ø³ØªØ§Ø¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    trim: true,\n    maxlength: [100, 'Ù†Ø§Ù… Ø§Ø³ØªØ§Ø¯ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  credits: {\n    type: Number,\n    required: [true, 'ØªØ¹Ø¯Ø§Ø¯ ÙˆØ§Ø­Ø¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    min: [1, 'ØªØ¹Ø¯Ø§Ø¯ ÙˆØ§Ø­Ø¯ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û± Ø¨Ø§Ø´Ø¯'],\n    max: [6, 'ØªØ¹Ø¯Ø§Ø¯ ÙˆØ§Ø­Ø¯ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û¶ Ø¨Ø§Ø´Ø¯']\n  },\n  group: {\n    type: Number,\n    min: [1, 'Ø´Ù…Ø§Ø±Ù‡ Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û± Ø¨Ø§Ø´Ø¯']\n  },\n  department: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'Ù†Ø§Ù… Ø¯Ø§Ù†Ø´Ú©Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  timeSlots: {\n    type: [TimeSlotSchema],\n    required: [true, 'Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø²Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø¯Ø±Ø³ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    validate: {\n      validator: function(slots: ITimeSlot[]) {\n        return slots.length > 0\n      },\n      message: 'Ø¯Ø±Ø³ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø²Ù…Ø§Ù† Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯'\n    }\n  },\n  examDate: Date,\n  examTime: {\n    type: String,\n    match: [/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'ÙØ±Ù…Øª Ø²Ù…Ø§Ù† Ø§Ù…ØªØ­Ø§Ù† Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª']\n  },\n  examLocation: {\n    type: String,\n    trim: true,\n    maxlength: [100, 'Ù…Ú©Ø§Ù† Ø§Ù…ØªØ­Ø§Ù† Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  color: {\n    type: String,\n    default: '#3B82F6',\n    match: [/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, 'Ø±Ù†Ú¯ Ø¨Ø§ÛŒØ¯ Ø¯Ø± ÙØ±Ù…Øª hex Ø¨Ø§Ø´Ø¯']\n  },\n  notes: {\n    type: String,\n    maxlength: [500, 'ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² ÛµÛ°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  }\n}, { timestamps: true })\n\nconst ScheduleSchema: Schema = new Schema({\n  userId: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  name: {\n    type: String,\n    required: [true, 'Ù†Ø§Ù… Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    trim: true,\n    maxlength: [100, 'Ù†Ø§Ù… Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  description: {\n    type: String,\n    trim: true,\n    maxlength: [500, 'ØªÙˆØ¶ÛŒØ­Ø§Øª Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² ÛµÛ°Û° Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯']\n  },\n  semester: {\n    type: String,\n    required: [true, 'ØªØ±Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    enum: ['Ù¾Ø§ÛŒÛŒØ²', 'Ø²Ù…Ø³ØªØ§Ù†', 'Ø¨Ù‡Ø§Ø±', 'ØªØ§Ø¨Ø³ØªØ§Ù†']\n  },\n  year: {\n    type: Number,\n    required: [true, 'Ø³Ø§Ù„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'],\n    min: [1400, 'Ø³Ø§Ù„ Ø¨Ø§ÛŒØ¯ Ø§Ø² Û±Û´Û°Û° Ø¨Ù‡ Ø¨Ø¹Ø¯ Ø¨Ø§Ø´Ø¯'],\n    max: [1450, 'Ø³Ø§Ù„ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ Ø§Ø² Û±Û´ÛµÛ° Ø¨Ø§Ø´Ø¯']\n  },\n  isActive: {\n    type: Boolean,\n    default: false\n  },\n  courses: {\n    type: [CourseSchema],\n    default: []\n  },\n  settings: {\n    showConflicts: { type: Boolean, default: true },\n    autoSave: { type: Boolean, default: true },\n    gridSize: { type: Number, default: 30, min: 15, max: 60 },\n    timeFormat: { type: String, enum: ['12', '24'], default: '24' }\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n})\n\n// Virtual for total credits\nScheduleSchema.virtual('totalCredits').get(function() {\n  return this.courses.reduce((total: number, course: ICourse) => total + course.credits, 0)\n})\n\n// Indexes\nScheduleSchema.index({ userId: 1, createdAt: -1 })\nScheduleSchema.index({ userId: 1, isActive: -1 })\nScheduleSchema.index({ 'courses.code': 1 })\nScheduleSchema.index({ 'courses.instructor': 1 })\n\n// Ensure only one active schedule per user\nScheduleSchema.pre('save', async function(next) {\n  if (this.isActive && this.isModified('isActive')) {\n    await mongoose.model('Schedule').updateMany(\n      { userId: this.userId, _id: { $ne: this._id } },\n      { isActive: false }\n    )\n  }\n  next()\n})\n\nexport default mongoose.model<ISchedule>('Schedule', ScheduleSchema)",
  "backend/src/controllers/authController.ts": "import { Request, Response, NextFunction } from 'express'\nimport jwt from 'jsonwebtoken'\nimport { validationResult } from 'express-validator'\nimport User, { IUser } from '../models/User'\nimport { asyncHandler } from '../utils/asyncHandler'\nimport { AppError } from '../utils/AppError'\nimport { logger } from '../utils/logger'\n\nconst signToken = (id: string) => {\n  return jwt.sign({ id }, process.env.JWT_SECRET!, {\n    expiresIn: process.env.JWT_EXPIRE || '7d',\n  })\n}\n\nconst createSendToken = (user: IUser, statusCode: number, res: Response) => {\n  const token = signToken(user._id)\n\n  const cookieOptions = {\n    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax' as const,\n  }\n\n  res.cookie('jwt', token, cookieOptions)\n\n  // Update last login\n  user.lastLogin = new Date()\n  user.save({ validateBeforeSave: false })\n\n  res.status(statusCode).json({\n    status: 'success',\n    token,\n    data: {\n      user,\n    },\n  })\n}\n\nexport const register = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª', 400, errors.array()))\n  }\n\n  const { name, email, password } = req.body\n\n  // Check if user already exists\n  const existingUser = await User.findOne({ email })\n  if (existingUser) {\n    return next(new AppError('Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª', 400))\n  }\n\n  // Create user\n  const user = await User.create({\n    name,\n    email,\n    password,\n  })\n\n  logger.info(`New user registered: ${email}`)\n  createSendToken(user, 201, res)\n})\n\nexport const login = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª', 400, errors.array()))\n  }\n\n  const { email, password } = req.body\n\n  // Check if user exists and password is correct\n  const user = await User.findOne({ email }).select('+password')\n\n  if (!user || !(await user.comparePassword(password))) {\n    return next(new AppError('Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª', 401))\n  }\n\n  if (!user.isActive) {\n    return next(new AppError('Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª', 401))\n  }\n\n  logger.info(`User logged in: ${email}`)\n  createSendToken(user, 200, res)\n})\n\nexport const logout = asyncHandler(async (req: Request, res: Response) => {\n  res.cookie('jwt', 'loggedout', {\n    expires: new Date(Date.now() + 10 * 1000),\n    httpOnly: true,\n  })\n\n  res.status(200).json({\n    status: 'success',\n    message: 'Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯'\n  })\n})\n\nexport const getMe = asyncHandler(async (req: Request, res: Response) => {\n  const user = await User.findById((req as any).user.id)\n\n  res.status(200).json({\n    status: 'success',\n    data: {\n      user,\n    },\n  })\n})\n\nexport const updatePassword = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req)\n  if (!errors.isEmpty()) {\n    return next(new AppError('Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª', 400, errors.array()))\n  }\n\n  const { currentPassword, newPassword } = req.body\n\n  // Get user with password\n  const user = await User.findById((req as any).user.id).select('+password')\n\n  if (!user) {\n    return next(new AppError('Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯', 404))\n  }\n\n  // Check current password\n  if (!(await user.comparePassword(currentPassword))) {\n    return next(new AppError('Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÙØ¹Ù„ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª', 401))\n  }\n\n  // Update password\n  user.password = newPassword\n  await user.save()\n\n  logger.info(`Password updated for user: ${user.email}`)\n  createSendToken(user, 200, res)\n})\n\nexport const refreshToken = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n  const user = await User.findById((req as any).user.id)\n\n  if (!user) {\n    return next(new AppError('Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯', 404))\n  }\n\n  createSendToken(user, 200, res)\n})"
}